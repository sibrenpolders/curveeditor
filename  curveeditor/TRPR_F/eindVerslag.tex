\documentclass[a4paper,11pt,oneside, titlepage]{article}
\author{Groep 13: Sibrand Staessens en Sibren Polders}
\title{Trimesteroverschrijdend Project: Curve Editor}
\date{Donderdag 22 mei, 2008}
\usepackage[dutch]{babel}
\usepackage{verbatim}
\usepackage{graphicx}
\usepackage[colorlinks,urlcolor=blue,filecolor=magenta]{hyperref}
\usepackage{url}
\parindent 0pt	
\hyphenation{Hermite deze Monitor-Pool}
\begin{document}
\maketitle \newpage
\tableofcontents \newpage
\section{Voorwoord}
Op welke manieren kan je een set van punten op een gladde wijze met elkaar verbinden? Dat was
de vraag achter Curve Editor. Het gemakkelijkste pad dat getekend kan worden tussen de punten
is natuurlijk lineair. Maar er zijn nog zoveel andere mogelijkheden, waarvan we er
slechts twee hebben verwerkt in curve editor (nl. Bezier en Hermite). Deze algoritmes zullen
vlakke kromme maken tussen de interpolatiepunten. De toepassingen van de algoritmes die we 
gebruikt hebben beperken zich niet enkel tot het tekenen van ``lijntjes'' tussen punten, 
maar ook op bijvoorbeeld camerabeweging of ``AI''-beweging in games.
De interpolatie tussen een gegeven set punten is een uitgebreide en interessante studie die 
op vele vlakken in de informatica/wiskunde zijn nut kan bewijzen. Curve editor geeft er de 
basistoepassing ( ofwel de toegepaste wiskundige ) ervan. \newline \newline \newline \newline
\newline \newline \newline \newline
%\begin{center}
%\textit{``If the path be beautiful, let us not ask where it leads.''} - Anatole France \newpage
%\end{center}
\newpage
\section{Wiskundige Voorkennis}
\subsection{lineair}
\subsubsection{Na\"ieve poging}
Een eerste poging om lineaire interpolatie uit te rekenen bestaat er in tussen elk puntenpaar
de vergelijking \begin{math}y = mx + b\end{math} uit te rekenen. 
Waarbij \begin{math}m = (y_1-y_0)/(x_1-x_0)\end{math} en b het
startpunt is op de y-as. De grote nadelen van dit algoritme zijn dat er voor iedere nieuwe
pixel opnieuw getekend moet worden en er behoefte is aan een floating point optelling en 
vermenigvuldiging ( vermits m een floating point is.
\subsubsection{DDA}
Bij deze methode wordt nog steeds m als floating point voorgesteld, maar de berekening van
de volgende y-waarde wordt als volgt vereenvoudigd:
\begin{math}
y_{i+1} = m.x_{i+1} + b\newline
=m.(x_i + \Delta x) + b\newline
=m.x_i + m.\Delta x) + b\newline
=y_i + m.\Delta x)\newline
=y_i + m) aangezien \Delta x = 1 als we 1 pixel verder gaan. \newline
\end{math} 
Dit algorithme is duidelijk efficienter vermits we een float vermenigvuldiging hebben 
uitgschakeld.
\subsection{Bezier}
\subsection{Hermite}
\newpage
\section{Implementatie}
\subsection{Packages}
\subsubsection{Java packages}
Een Java package is een mechanisme binnen Java om klassen te organiseren in namespaces. 
Java broncode die binnen eenzelfde categorie of functie vallen kunnen hierdoor gegroepeerd 
worden. Dit kan door middel van een package statement bovenaan het beginbestand om aan te 
geven waartoe ze behoren. Dit is om twee redenen handig omdat de sources gegroepeerd zijn
onder hun categorie, wat het geheel overzichtelijker maakt. Verder kunnen er nu twee 
verschillende klassen eenzelfde naam krijgen en toch uniek bepaald worden door er zijn
package name voor te zetten. Wat zeker handig is als de programmeur een klasse dezelfde naam
heeft gegeven als een klasse uit een library die hij wil gaan gebruiken.\newline \newline
Voor ons project hebben we een algemeen pakket src gemaakt die verschillende sub-pakketten bevat.
Wat duidelijk zichtbaar is in figuur BLAH.
In wat volgt wordt een korte beschrijving gegeven van al deze pakketten. Zonder al teveel in
te gaan op de technische details. 
\subsubsection{CurveEditor}
Dit is wellicht het kleinste pakket van de reeks (figuur BLAH). Het bevat slechts een klasse, 
namelijk de 
main klasse. Deze klasse zal, zoals wellicht duidelijk is, als bootstrap dienen voor de 
applicatie curve editor. Er wordt ook de mogelijkheid geboden om al rechtstreeks vanuit
de commandline een file mee te geven. Dit is enkel ter volledigheid vermits de gebruiker tijdens
de loop van het programma zeer makkelijk bestanden kan inladen en opslaan.
\subsubsection{Algorithms}
Dit pakket voorziet allerlei klassen die voor de interpolatie tussen punten zullen zorgen.
Elke klasse in dit pakket implementeert de Algorithme interface. Dit is handig voor de 
groepswerk vermits deze interface vastlegt welke functies de programmeur zal implementeren.
Zodoende weet je al op voorhand welke methodes je moet aanroepen om een bepaald resultaat
te verkrijgen. \newline
De klassenamen zijn triviaal gekozen: ``Lineair, Bezier, BezierC1, BezierG1, Hermite, 
Hermite Cardinaal, Hermite Catmull Rom''(figuur BLAH). 
Zoals de namen al veraden zullen deze de verschillende
interpolatie methodes die besproken werden in het deel 'Wiskundige voorkennis' implementeren.
Hiervoor werd natuurlijk altijd geoogd op de meeste optimale implementatie van degene die 
besproken werden.
\subsubsection{Core}
Dit pakket bevat enkele noodzakelijk klassen(figuur BLAH).\newline \newline
De klasse CurveContainer zal ervoor zorgen dat ingegeven punten kunnen opgeslagen worden, samen
met hun door interpolatie berekende punten. \newline \newline
Een eerste idee was het subdivsion principe toe te passen. In de beginsituatie is het tekenveld
dan een grote rechthoek. Van zodra de gebruiker een curve begint te tekenen worden de secties
waar punten geplaatst zijn onderverdeeld in steeds kleiner wordende rechthoekjes. In elk zo'n
rechthoekje zat dan juist een punt van een curve. Zodat er gemakkelijk gezegd kon worden
welk punt waar stond en tot welke curve het behoorde.\newline
Dit algorithme bleek echter niet zo effici\"ent te zijn wanneer we te maken hadden met een groot
aantal input punten. Dit kwam voornamelijk doordat er telkens opnieuw een kleinere rechthoek
moest berekend worden bij ingeven van een nieuw punt. En een grotere wanneer er punten verwijderd
werden. Uiteindelijk was de applicatie meer bezig met het berekenen van rechthoekjes dan met zijn
doel: voorstellen van curves.\newline \newline
De tweede poging leek beter te lukken. We stelden een veld op waarvan elke pixel een mogelijke
houder kon zijn van een punt. De houders werden ge\"initialiseerd met de waarde null zodat ze 
geen
plaats innamen. Het toevoegen van punten is zo simpel uit te voeren door het new commando toe
te passen. Verwijderen is dan gewoon de juist holder op null zetten ( de garbage collection van
java lost de rest op ). Het zoeken gaat simpelweg door de positie van de muisklik om te 
zetten naar co\"ordinaten die gebruikt kunnen worden op de vector waarin alle punten worden 
opgeslagen. Om daarna in een bepaalde vooraf bepaalde range te kijken of een punt houder niet
op null staat, is dat zo dan zal de informatie van dat punt teruggeven worden, zoniet is er op
die plaats in het veld geen punt beschikbaar.\newline \newline
De klasse Editor is het hart van de curve editor. Deze zal zorgen dat de data die uitgewisseld
moet worden kan en ook in de juiste richting zal stromen. De uitwisseling van data zal 
voornamelijk bestaan uit het zoeken of verwijderen van punten uit de CurveContainer klasse.
Maar ook het opvangen en afhandelen van excepties. Deze klasse zorgt er dus voor dat de 
verschillende andere klassen zo autonoom als mogelijk kunnen werken. Dit verhoogd natuurlijk
enkel de leesbaarheid en onderhoudbaarheid van de code.\newline \newline
Een laatste klasse van dit pakket is de FileIO klasse, deze zal niet alleen files opslaan en
inladen, maar ook zal hij de functionialiteit van undo en redo implementeren, vermits deze van
dezelfde functies gebruik maakt.
\subsubsection{Curve}
Dit pakket bevat de de twee datatypes die doorheen het programma gebruikt worden. Point zoals
de naam doet vermoeden geeft de mogelijkheid een punt op te slaan. Curve geeft dan weer de
mogelijkheid om een verzameling van punten ( lees een kromme of curve ) op te slaan. De
technische details van deze laatste klasse wordt beter uitgelegd verder in de tekst. 
Voorlopig is het voldoende om te weten dat Curve een vector van Point's bijhoudt en enkele
basisvoorzieningen voorziet ( punten opvragen, toevoeg, transleren, \ldots ).
\subsubsection{Exceptions}
Een foutloos programma schrijven is al een hele opgave, vermits er altijd wel kleine bugs
kunnen opduiken na langdurig gebruik. Een fool proof programma schrijven daarentegen is een
onmogelijke opgave. Daarom hebben we gebruik gemaakt van exceptions om ``verkeerd'' gebruik van
curve editor op te vangen. Onder verkeerd gebruik valt bijvoorbeeld het inladen van een
onbestaande file, of een verkeerd fileformat. Het toevoegen van een punt zonder er de 
co\"ordinaten van op te geven, \ldots.\newline \newline
Er zijn ook twee HandleException klassen voorzien. Eentje in dit pakket, deze zal gewoon 
het exceptie bericht in de console uitprinten. In het GUI pakket is een HandleException klasse
voorzien die in een dialog scherm de exceptie zal uitprinten.
\subsubsection{GUI}
De GUI is vrij grondig opgesplitst( zie figuur BLAH ). Elk groot deel heeft zo zijn eigen klasse.
Zo heb je een menubalk klasse, een snelknopbalk klasse, een tekengebied klasse en een keuzegebied
klasse. De GUI klasse op zijn beurt zal het centrale orgaan spelen die al deze klassen 
connecteerd. Het is daarom ook niet te verwonderen dat deze is afgeleid van de klasse Editor,
die centrale klasse was van de core van de applicatie. 

Hoewel het opdelen van de GUI in verschillende klassen heeft enorme voordelen als we spreken 
over leesbaarheid en onderhoudbaarheid van code. Het eventhandle systeem van java is zelf
optimaal voor dit soort afscheiding. In java worden de events opgevangen door een klasse 
af te leiden van een van de Listener interface's (ActionListener, ItemListener, ... ). Deze 
klasse zal dan de nodige member functies impementeren om de juiste evenafhandeling te kunnen
doen. Het is dus voldoende om deze event handle klassen in GUI aan te maken en door te geven
aan de juiste componenten ( menubalk, tekengebied, ... ). Meer uitleg hierover vind je verder in
de tekst.
\subsubsection{Tools}
Dit bevat de een curve simulator. In principe is het een ``sjieke'' naam voor een bolletje
dat over het pad loopt. Dit kan gebruikt worden door de gebruiker om de stijging en daling
van de curve te bestuderen.
\subsection{Uitwerking van de GUI}
\subsubsection{Overzicht}

Zoals in screenshot BLAH te zien is kan de vormgeving van de GUI in 4 grote stukken opgedeeld 
worden.
\begin{enumerate}
\item Menubalk ( fig BLAH)
Hierin kan de gebruiker elke actie terugvinden die door het programma kan uitgevoerd worden.
Bijna elke actie is ook te bereiken met keyboard sneltoetsen ( Alt-F, Ctrl-O, \ldots ) zodat
elke gebruiker op zijn lievelingsmethode kan navigeren door de verschillende uitvoerbare taken.
Er is telkens op gelet dat de nesting van de menu-items niet te diep is noch te breed, verder
is elke naam zo triviaal mogelijk gekozen en meestal ook voorzien van een icoon. Dit alles
om het gebruiksgemak te verhogen.
\item Snelknopbalk ( fig BLAH)
Hierin vind je enkele veel gebruikte taken terug ( nieuw bestand, een bestand openen, 
nieuwe curve, \ldots ). Dit opdat de gebruiker deze taken snel en en dus effici\"enter kan
afhandelen.
\item Keuzegebied ( fig BLAH)
In dit gebied zal de gebruiker snel kunnen kiezen welk soort curve hij wil tekenen (bezier, 
hermite, \ldots ) en kan hij ten alle tijden een punt toevoegen door zijn co\"ordinaten in te
geven. Verder kan de gebruiker hier ook altijd kiezen of hij de co\"ordinaten, tangens en 
puntnummers wil laten zien bij het tekenen. \newline
Het Edit-veld van dit gebied hangt af van de Modus waarin je zit. Er zijn voor de gebruiker
twee grote modi zichtbaar. De ene is curve modus, hier bewerk je curves ( selecteren, 
deselectere, nieuwe curve, \ldots ) en de punt modus ( punt verslepen, selecteren, toevoegen ).
Naargelang de modus waarin je zit zulle andere mogelijkheden zichtbaar worden in het edit veld.
Dit leidt tot een groter gebruiksgemak vermits de taken die verschijnen meestal ook gebruikt
worden waneer je in de modus werkt.
\item Tekengebied ( fig BLAH )
Dit gebied is waarschijnlijk wel het interessantste voor de gebruiker. Met behulp van muis
interactie kan de gebruiker punten aan dit veld toevoegen en deze punten laten connecteren
door een interpolatie methode. De gebruiker kan tevens in dit veld punten en curves selecteren,
verwijderen en zelf verslepen. Het tekengebied maakt gebruik van double buffering om 
beeldflikkering te vermijden en ook van clipping zodat alleen getekend wordt wat ook echt
op het scherm verschijnt.
\end{enumerate}
\subsection{Java Listeners}
Java heeft een aparte stijl om events op te vangen ( signalen gestuurd door buttons, menu items,
\ldots ). De taal bezit hiervoor zogenaamde event listener interfaces. De programmeur
moet een klasse aanmaken die een dergelijke interface zal implementeren. Deze klasse wordt dan
m.b.v. een simpel commando geconnecteerd met een bepaald component ( bijvoorbeeld een button ).
In de interface is er een eventhandle functie gedefini\"eerd die dan door de programmeur zal 
ge\"implementeerd worden zodat, wanneer het component een signaal uitvoert,
de opgevangen event afhandeld zal worden.\newline

Dit systeem is pas echt voordelig als je een event moet afhandelen in een geneste klasse 
structuur. Stel bijvoorbeeld je hebt in een klasse A een instantie van een Klasse B zitten
die op zijn beurt weer een instantie heeft van klasse C en je wilt dan klasse A een handeling
doet als klasse C een event uitstuurt( figuure BLAH ). 
Met callbacks is de properste manier (om klasse onafhankelijkheid te bewaren), een callback 
te connecteren van klasse A naar klasse B, daarna een callback van klasse B naar klasse C. 
Bij java kan ge gewoon een event handle klasse vanuit klasse A meegeven aan B die het op zijn 
beurt meegeeft aan klasse C. Wat de code natuurlijk wat overzichtelijker maakt.\newline \newline

In deze implementatie is ervoor gekozen om deze eventhandle klassen in de klasse GUI te 
defini\"eren. Het voordeel hiervan is dat de enkel de klasse GUI de eventhandle klassen kan 
instanti\"eren en deze instanties zulle alle member variabele en functies van GUI kunnen 
gebruiken. Wat ervoor zorgt dat er geen extra connectie moet gelegd worden tussen de 
eventhandle klassen en GUI (Een soort van friendly class die niet ge\"instantieerd kan worden 
dus). 
\subsection{Datastructuren}
\subsubsection{Point}
Deze datastructuur heeft niet zoveel uitleg nodig, een Point bestaat uit zijn x- en y-waarde
en de nodige get() en set() functies. Het dient, zoals de naam al doet vermoeden, om een punt
in een vlak voor te stellen.
\subsubsection{Curve}
Deze structuur heeft al iets meer uitleg nodig. Een curve is op het laagste niveau niets dan
een container van punten.\newline
Elke curve Houdt drie essentiele dingen bij
\begin{enumerate}
\item Type ( bezier, hermite, \ldots )
\item een vector van input punten
\item een vector van output punten
\end{enumerate}

Hierbij worden type en de input punten gegeven door de gebruiker. De vector van output punten
wordt intern berekend door de verschillende interpolatie algoritmes. Daarna wordt de vector
gebruikt om te kunnen tekenen op het tekengebied.\newline

We hebben voor een vector gekozen om de input punten op te slaan omdat de verschillende
interpolatietechnieken gemakkelijk moeten kunnen springen tussen de gegeven input punten om
hun algorithme te kunnen uitvoeren. Voor de output punten hebben we dan gekozen voor een 
enkelvoudig gelinkte lijst vermits de punten maar in een richting dienen toegevoegd en gelezen
te worden.

Deze klasse bevat ook nog functies om punten te verwijderen, toe te voegen, om na te gaan of een gegeven punt al dan niet tot de curve, \ldots
\subsection{Extra's}
TODO
\subsection{Interessante problemen}
TODO
\newpage
\section{Planning}
\newpage
\section{Taakverdeling}
\begin{enumerate}
\item Sibrand Staessens:
       Bezier algorithmes, CurveContainer, Editor, DrawArea, GUI
\item Sibren Polders
       Hermite algorithmes, FileIO, Menu, ToolBar, ChoiceArea, GUI, PathSimulation
\end{enumerate}
\newpage
\section{Appendix}
\appendix
\section{Handleiding}
Had gij dacht ik?
\section{Screenshot}
Gij ook? Alleja ik ga kijken welke gij al hebt en dan bijmaken wat ik nodig heb. Zodoende gaan
we geen dubbel werk leveren \ldots. ``Stel niet uit tot morgen wat je vandaag door een ander
kan laten doen''
\section{Referenties}
Prof. dr. F. VAN REETH, Prof. dr. P. BEKAERT, 2007-2008, Computer Graphics 
\end{document}
