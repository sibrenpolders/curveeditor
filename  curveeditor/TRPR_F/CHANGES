*Heb File in FILEIO veranderd anders waren er wat problemen met FILE van java zelf...
*Menu is operationeel ( whii ). Maar er moeten nog veel functies ingevuld worden + ik moet nog een
degree aanvinker zetten voor bezier & hermites. Maar ge moet eens doorgeven hoe ge dat juist zou willen
Gewoon een radiobutton met beperkte keuzens? een spinner? En welke opties moeten daar eventueel nog bijkomen?
*Heb FileIO ook meteen ingevuld ( ik dacht kan nog rap zoiets kleins doen. Bleek meer werk dan ik dacht
( zie de tijd ). Het plan was toch om daar een xml file voor te maken? Heb de dtd en een sample in Saves
gestoken. Beetje goed zo? 
 In principe werken Save en Load ( Load toch zeker ). Wel 1 probleem de Vector ja lees VECTOR:) van curves
 is blijkbaar leeg? Ik weet het niet zeker maar ik gok dat het iets te maken heeft met het feit dat
 gij die vector opvult als een lijst? ( vector is afgeleid van lijst, dacht ik toch, en dus zal
 de cast wel werken maar de teller zal niet verhoogt worden zoiets dan. ) Waarom gebruikt ge daar trouwens opeens een
 lijst? Is het niet beter van ofwel overal een vector te gebruiken ofwel overal een lijst?
 *Krijg af en toe een fout? zeer raar. Maar af en toe krijg ik dit:
 Exception in thread "AWT-EventQueue-0" java.lang.ArrayIndexOutOfBoundsException: Array index out of range: 66
	at java.util.Vector.get(Vector.java:694)
	at CurveEditor.GUI.DrawArea.paintComponent(DrawArea.java:53)
	at javax.swing.JComponent.paint(JComponent.java:1027)
	at javax.swing.JComponent.paintChildren(JComponent.java:864)
	at javax.swing.JComponent.paint(JComponent.java:1036)
	at javax.swing.JComponent.paintChildren(JComponent.java:864)
	at javax.swing.JComponent.paint(JComponent.java:1036)
	at javax.swing.JLayeredPane.paint(JLayeredPane.java:564)
	at javax.swing.JComponent.paintChildren(JComponent.java:864)
	at javax.swing.JComponent.paintToOffscreen(JComponent.java:5129)
	at javax.swing.BufferStrategyPaintManager.paint(BufferStrategyPaintManager.java:285)
	at javax.swing.RepaintManager.paint(RepaintManager.java:1128)
	at javax.swing.JComponent.paint(JComponent.java:1013)
	at java.awt.GraphicsCallback$PaintCallback.run(GraphicsCallback.java:21)
	at sun.awt.SunGraphicsCallback.runOneComponent(SunGraphicsCallback.java:60)
	at sun.awt.SunGraphicsCallback.runComponents(SunGraphicsCallback.java:97)
	at java.awt.Container.paint(Container.java:1797)
	at javax.swing.RepaintManager.paintDirtyRegions(RepaintManager.java:734)
	at javax.swing.RepaintManager.paintDirtyRegions(RepaintManager.java:679)
	at javax.swing.RepaintManager.seqPaintDirtyRegions(RepaintManager.java:659)
	at javax.swing.SystemEventQueueUtilities$ComponentWorkRequest.run(SystemEventQueueUtilities.java:128)
	at java.awt.event.InvocationEvent.dispatch(InvocationEvent.java:209)
	at java.awt.EventQueue.dispatchEvent(EventQueue.java:597)
	at java.awt.EventDispatchThread.pumpOneEventForFilters(EventDispatchThread.java:273)
	at java.awt.EventDispatchThread.pumpEventsForFilter(EventDispatchThread.java:183)
	at java.awt.EventDispatchThread.pumpEventsForHierarchy(EventDispatchThread.java:173)
	at java.awt.EventDispatchThread.pumpEvents(EventDispatchThread.java:168)
	at java.awt.EventDispatchThread.pumpEvents(EventDispatchThread.java:160)
	at java.awt.EventDispatchThread.run(EventDispatchThread.java:121)
 
 Komt van blijkbaar van DrawArea regel 53. Enig idee hoe het komt?
 *Zal verder hier en daar wel nog iets onbeduidend veranderd hebben.
 
 -----------
 
 *	Ahja, nie aan gedacht.
 *	Ik zou orde 2,3,4 en 5 voorzien. Dan berekent 'ie een curve per groepje van 3,4,5 of 6 punten. 
 	Tuurlijk, je kan oneindig ver gaan, 't is niet eens zo moeilijk om te implementeren... maar 'k vind dat als je per groepjes werkt, 
 	groepjes van zes al groot genoeg is. 't Is niet de bedoeling dat de gebruiker dat tekenvlak supervol met controlepunten zet h√©.
 	Naast die specifiek bepaalde ordes zou ik ook 'n optie "Unlimited" of zo voorzien: die berekent dan een curve a.h.v. ALLE invoerpunten.
 *	DTD ziet er goed uit op het eerste zicht. Nu, 't zit ver weg bij mij, maar kan het zijn dat
 	<!ELEMENT curveEditor (curve*)> beter is ? En mss ook dit: <!ELEMENT curve (type,degree,point+)> ?
 *	List is een interface in Java, daar kan je dus geen instantie van aanmaken. Had ik pas later door toen dat Eclipse daarover zat te klagen.
 	'k Had dan Vector gebruikt... maar 't kan zijn dat ik het niet overal heb aangepast.
 *	Hmm, die fout is wel bizar... die zou die vector pas mogen uittekenen nadat 'ie gevuld is. Implementatie spreekt dan ook voor zich.
 	Ik vermoed dat Java zelf threadingoptimalisaties doorvoert en dat er dan zo'n dingen voorvallen.
 ----
 
 *	DTD is aangepast ge had gelijk( het zit ook nog ver bij mij )
 *	DrawArea zit vol lijsten:D. De constructor aanpassen moet het normaal oplossen. Ik wou het niet doen
 	omdat ge er misschien een goede reden voor had.
 *  Ok momenteel geen andere opties dan de orde? Dan zal ik die al implementeren ( morgen of overmorgen )